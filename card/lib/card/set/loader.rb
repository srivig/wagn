# -*- encoding : utf-8 -*-

class Card
  module Set
    # the set loading process has two main phases:

    #  1. Definition: interpret each set file, creating/defining set and
    #     set_format modules
    #  2. Organization: have base classes include modules associated with the
    #     'all' set, and clean up the other modules
    module Loader
      # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      # Definition Phase

      # each set file calls `extend Card::Set` when loaded
      def extended mod
        register_set mod
      end

      # make the set available for use
      def register_set set_module
        if set_module.all_set?
          # automatically included in Card class
          modules[:base] << set_module
        else
          set_type = set_module.abstract_set? ? :abstract : :nonbase
          # made ready for dynamic loading via #include_set_modules
          modules[set_type][set_module.shortname] ||= []
          modules[set_type][set_module.shortname] << set_module
        end
      end

      #
      #  When a Card application loads, it uses set modules to autogenerate
      #  tmp files that add module names (Card::Set::PATTERN::ANCHOR) and
      #  extend the module with Card::Set.
      #

      #
      #
      def write_tmp_file from_file, to_file, rel_path
        name_parts = rel_path.gsub(/\.rb/, '').split(File::SEPARATOR)
        submodules = name_parts.map { |a| "module #{a.camelize};" } * ' '
        file_content = <<EOF
# -*- encoding : utf-8 -*-
class Card; module Set; #{submodules} extend Card::Set
# ~~~~~~~~~~~ above autogenerated; below pulled from #{from_file} ~~~~~~~~~~~
#{File.read from_file}

# ~~~~~~~~~~~ below autogenerated; above pulled from #{from_file} ~~~~~~~~~~~
end;end;#{'end;' * name_parts.size}
EOF

        FileUtils.mkdir_p File.dirname(to_file)
        File.write to_file, file_content
        to_file
      end

      # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      # Organization Phase

      # 'base modules' are modules that are permanently included on the Card or
      # Format class
      # 'nonbase modules' are included dynamically on singleton_classes
      def process_base_modules
        process_base_module_list modules[:base], Card
        modules[:base_format].each do |format_class, modules_list|
          process_base_module_list modules_list, format_class
        end
        modules.delete :base
        modules.delete :base_format
      end

      def process_base_module_list list, klass
        list.each do |mod|
          klass.send :include, mod if mod.instance_methods.any?
          if (class_methods = mod.const_get_if_defined(:ClassMethods))
            klass.send :extend, class_methods
          end
        end
      end

      def clean_empty_modules
        clean_empty_module_from_hash modules[:nonbase]
        modules[:nonbase_format].values.each do |hash|
          clean_empty_module_from_hash hash
        end
      end

      def clean_empty_module_from_hash hash
        hash.each do |mod_name, modlist|
          modlist.delete_if { |x| x.instance_methods.empty? }
          hash.delete mod_name if modlist.empty?
        end
      end
    end
  end
end
